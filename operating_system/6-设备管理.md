# 实验6 设备管理

1. 实验内容:
    设备管理是指计算机系统对除CPU和内存以外的所有输入、输出设备的管理。通过本次实验，你将理解设备管理的概念和任务。在阅读理解并运行所给代码的基础上，掌握独占设备的分配、回收等主要算法的原理。
2. 实验要点:
    理解设备管理的概念和任务。
    掌握独占设备的分配、回收等主要算法的原理并编程实现。

3. 实验目的及实验内容
    - 实验目的
        1. 理解设备管理的概念和任务。
        2. 掌握独占设备的分配、回收等主要算法的原理并编程实现。

    - 实验内容
        1. 阅读操作系统设备管理相关概念
        2. 精读所给代码并熟悉代码中的数据结构和函数，编译运行程序体会设备管理的过程，掌握独占设备的分配、回收等主要算法的原理。

## 设备管理概述

### 一、设备管理的任务和功能

设备管理的主要任务是完成用户提出的I/O请求，为用户分配I/O设备，提高I/O设备的利用率，方便用户使用I/O设备。设备管理应该具备以下功能：

1. 设备分配。按照设备类型和相应的分配算法决定将I/O设备分配给哪一个要求使用该设备的进程。如果在I/O设备与CPU之间还存在着设备控制器和通道，则还需分配相应的控制器和通道，以保证I/O设备与CPU之间有传递信息的通路。凡未分配到所需设备的进程应放入一个等待队列。为了实现设备分配，系统中应设置一些数据结构，用于记录设备的状态。

2. 设备处理。设备处理程序实现CPU和设备控制器之间的通信。即当CPU向设备控制器发出I/O指令时，设备处理程序应启动设备进行I/O操作，并能对设备发来的中断请求做出及时的响应和处理。

3. 缓冲管理。设置缓冲区的目的是缓和CPU与I/O设备速度不匹配的矛盾。缓冲管理程序负责完成缓冲区的分配和释放及有关的管理工作。

4. 设备独立性。设备独立性又称设备无关性，是指应用程序独立于物理设备。用户在编制应用程序时，要尽量避免直接使用实际设备名。如果程序中使用了实际设备名，则当该设备没有连接在系统中或者该设备发生故障时，用户程序无法运行，若要运行此程序则需要修改程序。如果用户程序不涉及实际设备而使用逻辑设备，那么它所要求的输入/输出便与物理设备无关。设备独立性可以提高用户程序的可适应性，使程序不局限与某个具体的物理设备。

### 二、设备控制器与I/O通道

#### 设备控制器

设备一般由机械和电子两部分组成，设备的电子部分通常称为设备控制器。设备控制器处于CPU与I/O设备之间，它接收从CPU发来的命令，并去控制I/O设备工作，使CPU从繁杂的设备控制事务中解脱出来。
设备控制器是一个可编址设备，当它仅控制一个设备时，它有一个设备地址；当控制器连接多个设备时，则应具有多个设备地址，使每一个地址对应一个设备。

设备控制器应具有以下功能：接收和识别来自CPU的各种命令，实现CPU与设备控制器、设备控制器与设备之间的数据交换，记录设备的状态供CPU查询，识别它所控制的每个设备地址。为此，设备控制器中应设置控制寄存器存放接收的命令及参数，设置数据寄存器存放传输的数据，设置状态寄存器记录设备状态。

#### I/O通道

在一般计算机系统中，通道指专门用于负责输入/输出工作的处理机。通道有自己的指令系统，该指令系统比较简单，一般只有数据传送指令、设备控制指令等。通道所执行的程序称为通道程序。

根据信息交换方式的不同，可以将通道分成以下几种类型：

1. 字节多路通道。字节多路通道按字节交换方式工作。它通常都含有若干个非分配型子通道，每个子通道连接一台I/O设备，这些子通道按时间片轮转方式共享主通道，当一个子通道控制其I/O设备交换完一个字节后，立即让出字节多路通道（主通道），以便让另一个子通道使用。字节多路通道一般用于连接中、低速I/O设备。一个字节多路通道可以连接多台中、低速设备。

2. 数据选择通道。数据选择通道又称数组选择通道，它以成组方式进行数据传输，即每次传输一批数据，传输的速率很高。数据选择通道只含有一个分配型子通道，在一段时间内只能执行一个通道程序，控制一台设备进行数据传送，当一个I/O请求操作完成后，再选择与通道相连的另一台设备。这样当某台设备占用了该通道时，便一直由它独占，直至该设备传送完毕释放该通道为止。由此可见，这种通道的利用率很低，一般用于连接高速I/O设备。

3. 数据多路通道。数据多路通道又称数组多路通道，它结合了数据选择通道传输速度高和字节多路通道能进行分时并行操作的优点，这使得它既具有很高的数据传送速率，又能获得满意的通道利用率。数据多路通道以分时的方式执行几个通道程序，它每执行一个通道程序的一条通道指令控制传送一组数据后，就转向另一个通道程序。这种通道广泛用于连接高、中速I/O设备。

## 输入输出控制方式

### 一、程序直接控制方式

在早起的计算机系统中，由于无中断机构，处理机对I/O设备的控制采用程序直接控制方式，下面以数据输入为例说明这种I/O控制方式。
当用户进程需要输入数据时，由处理机向设备控制器发出一条I/O指令启动设备进行输入，在设备输入数据期间，处理机通过循环执行测试指令不间断地检测设备状态寄存器的值，当设备状态寄存器的值显示设备输入完成时，处理机将数据寄存器中的数据取出，送入内存指定单元，然后再启动设备去读下一个数据。
反之，当用户进程需要向设备输出数据时，也必须同样发出启动命令启动设备输出并等待输出操作完成。

程序直接控制方式的工作过程非常简单，但CPU的利用率相当低。因为CPU执行指令的速度高出I/O设备几个数量级，所以在循环测试中浪费了大量的CPU处理时间。

### 二、中断控制方式

在现代计算机中，对I/O设备的控制广泛采用了中断控制方式。这种控制方式要求CPU与设备之间有相应的中断请求线，且要求在状态寄存器中有中断允许位。

在I/O中断方式下，数据的输入按如下步骤操作：

1. 首先，需要数据的进程通过CPU发出启动指令启动外设输入数据。该指令同时还将状态寄存器中的中断允许位打开。

2. 在进程发出指令启动设备之后，该进程放弃处理机，等待输入完成。而进程调度程序调度其他就绪进程占据处理机。

3. 当输入完成时，I/O控制器通过中断请求线向CPU发出中断信号。CPU在接收到中断信号之后，转向设备中断处理程序。设备中断处理程序将输入数据寄存器中的数据传送到某一特定内存单元中，以便供要求输入的进程使用。同时还把等待完成的那个进程唤醒，再返回到被中断的进程继续执行。

4. 在以后的某个时刻，进程调度程序选中提出请求输入的进程，该进程从约定的内存单元中取出数据做进一步处理。

与程序直接控制方式相比，中断控制方式大大提高了CPU的利用率。但这种控制方式仍然存在许多问题，如每台设备每输入/输出一个数据都要求中断CPU，这样在一次数据传送过程中，中断发生的次数较多，从而耗去大量CPU处理时间。

### 三、DMA控制方式

DMA控制方式的基本思想是在外围设备和内存之间开辟直接的数据交换通路。
在DMA控制方式中，I/O控制器具有更强的功能，在它的控制下，设备和内存之间可以成批地进行数据交换，而不用CPU干预。
这样既大大减轻了CPU的负担，也使I/O数据传送速度大大提高。
这种方式一般用于块设备（块设备处理信息的基本单位是字符块。一般块的大小为512B~8KB）的数据传输。

DMA控制方式下进行数据输入的过程如下：

1. 当进程要求设备输入一批数据时，CPU将准备存放输入数据的内存始址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器；另外，还要将中断位和启动位设置为1，以启动设备开始进行数据输入，并允许中断。

2. 发出数据请求的进程进入等待状态，进程调度程序调度其他进程占据CPU。

3. 输入设备不断地挪用CPU工作周期，将数据寄存器中的数据源源不断地写入内存，直到所要求的字节全部传送完毕。

4. DMA控制器在传送字节数完成时通过中断请求线发出中断信号，CPU收到中断信号后转去执行中断处理程序，唤醒等待输入完成的进程，并返回被中断程序。

5. 在以后的某个时刻，进程调度程序选中提出请求输入的进程；该进程从指定的内存单元取出数据并做进一步的处理。

DMA控制方式与中断控制方式的主要区别是：中断控制方式在每个数据传送完成后中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时中断CPU.
中断控制方式的数据传送是在中断处理时由CPU控制完成，而DMA控制方式则是在DMA控制器的控制下完成的。

不过DMA控制方式仍然存在一定的局限性，如数据传送的方向、存放数据的内存始址及传送数据的长度等都由CPU控制，并且每台设备需一个DMA控制器，当设备增加时，多个DMA控制器的使用也不经济。

### 四、通道控制方式

通道控制方式与DMA控制方式类似，也是一种以内存为中心，实现设备与内存直接交换数据的控制方式。与DMA控制方式相比，通道所需要的CPU干预更少，且可以做到一个通道控制多台设备，从而更进一步减轻了CPU的负担。

#### 1. 设备分配

    设备分配是设备管理的功能之一，当进程向系统提出I/O请求之后，设备分配程序将按照一定的分配策略为其分配所需的设备。同时还要分配相应的控制器和通道，以保证CPU与设备之间的通信。

##### 一、设备分配中的数据结构

为了实现对I/O设备的管理和控制，需要对每台设备、通道、控制器的情况进行登记。设备分配依据的主要数据结构有设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）和系统设备表（SDT）。

系统为每一个设备配置一张设备控制表，用于记录设备的特性及与I/O控制器连接的情况。设备控制表中包括设备标识符、设备类型、设备状态、设备等待队列指针、指向控制器控制表的指针等。其中，设备状态用来指示设备是忙还是闲，设备等待队列指针指向等待使用该设备的进程组成的等待队列，控制器控制表指针指向与该设备相连接的设备控制器。

每个控制器都配有一张控制器控制表，它反映设备控制器的使用状态以及和通道的连接情况。控制器控制表中包括控制器标识符、控制器状态（忙/闲）、控制器等待队列指针、与控制器连接的通道控制表指针等。

每个通道也都配有一张通道控制表。通道控制表包括通道标识符、通道状态、等待获得该通道的进程等待队列指针等。

整个系统只有一张系统设备表，它记录了已连接到系统中的所有物理设备的情况，每个物理设备占一个表目。系统设备表的每个表目包括设备类型、设备标识符、设备控制表指针等。其中，设备控制表指针指向该设备对应的设备控制表。

##### 二、设备分配策略

在计算机系统中，请求设备为其服务的进程数往往多余设备数，这样就出现了多个进程队某类设备的竞争问题。为了保证系统有条不紊地工作，系统在进行设备分配时，应考虑以下几个因素。

###### 1. 设备的使用性质

按照设备自身的使用性质，可以采用以下3中不同的分配方式：

1. 独享分配。又称独占设备。即在将一个设备分配给某进程后便一直由该进程独占，直至该进程完成或释放该设备后，系统才能再将该设备分配给其他进程使用。如打印机就不能由多个进程共享，而应采取独享分配方式。实际上，大多数低速设备都适合采用这种分配方式，这种分配方式的主要缺点是I/O设备通常得不到充分利用。

2. 共享分配。对于共享设备，可以将它同时分配个多个进程使用。如磁盘是一种共享设备，因此可以分配给多个进程使用。共享分配方式显著提高了设备的利用率，但对设备的访问需要进行合理调度。

3. 虚拟分配。虚拟分配是针对虚拟设备而言的，其实现过程是：当进程申请独占设备时，系统给它分配共享设备上的一部分存储空间；当进程要与设备交换信息时，系统就把要交换的信息存放在这部分存储空间中；在适当的时候，将设备上的信息传输到存储空间中或将存储空间中的信息传送到设备。

##### 2.设备分配算法

I/O设备的分配除了与I/O设备的固有属性相关外，还与系统所采用的分配算法有关。设备分配主要采用先请求先服务和优先级高者优先算法。

##### 3.设备分配的安全性

所谓设备分配的安全性是指设备分配中应防止发生进程死锁。在进行设备分配时，可以采用静态分配和动态分配两种方式。
静态分配是在作业级进行的，用户作业开始执行之前，由系统一次分配该作业所要求的全部设备、控制器和通道。一旦分配，这些设备、控制器和通道就一直为该作业所占用，直到该作业撤销为止。
静态分配方式不会出现死锁，但设备的利用率低。

动态分配是在进程执行过程中根据执行需要进行的设备分配。
当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按照事先规定的策略给进程分配所需要的设备、控制器和通道，一旦用完之后，立即释放。
动态分配方式有利于提高设备的利用率，但如果分配算法不当，则有可能造成进程死锁。

在进行动态分配时也分两种情况。在某些系统中，每当进程发出I/O请求后，便立即进入阻塞状态，直到所提出的I/O请求完成才被唤醒。在这种情况下，设备分配时安全的，单进程推进缓慢。在有的系统中，运行进程发出I/O请求后仍然继续进行，并且在需要时又可以发出第二个I/O请求，第三个I/O请求…，仅当进程所请求的设备已被另一进程占用时才进入阻塞状态。这样一个进程有可能同时操作多个设备，从而使进程推进迅速，但这种设备分配有可能产生死锁。

##### 5.设备独立性

设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关。为此，要求用于程序对I/O设备的请求采用逻辑设备名，而在程序实际执行时使用物理设备名，它们之间的关系类似于存储管理中的逻辑地址与物理地址。

### 三、设备分配步骤

（1）单通路I/O系统的设备分配

    当某一进程提出I/O请求后，系统的设备分配程序可以按下述步骤进行设备分配：

    ①分配设备。根据进程提出的物理设备名查找系统设备表，从中找到该设备的设备控制表。查看设备控制表中的设备状态字段，若该设备处于忙状态，则将进程插入到设备等待队列；若设备空闲，便按照一定的算法来计算本次设备分配的安全性，若分配不会引起死锁则进行分配；否则仍将该进程插入设备等待队列。

    ②分配控制器。在系统把设备分配给请求I/O的进程后，再到设备控制表中找到与该设备相连的控制器控制表，从该表的状态字段中可以知道该控制器是否忙碌。若控制器忙碌，则将进程插入该控制器的等待队列；否则将该控制器分配给进程。

    ③分配通道。从控制器控制表中找到与该控制器连接的通道控制表，从该表的状态字段中可以知道该通道是否忙碌。若通道处于忙碌状态，则将该进程插入该通道的等待队列；否则将该通道分配给进程。若分配了通道，则此次设备分配成功，在将相应的设备、控制器、通道分配给进程后，便可以启动I/O设备实现I/O操作了。

（2）多通路I/O系统的设备分配

    为了提高系统的灵活性和可靠性，通常采用多通路的I/O系统结构。在这种系统结构中，一个设备可以与几个控制器相连，而一个控制器又可以与几个通道相连，这使得设备分配的过程较单通路的情况要复杂些。若某进程向系统提出I/O请求，要求为它分配一台I/O设备，则系统可以选择该类设备中的任何一台设备分配给该进程，其步骤如下：

1. 根据进程所提供的设备类型，检测系统设备表，找到第一个该类设备的设备控制表，由其中的状态字段可以知道其忙碌情况，若设备忙，则检查第二个该类设备的设备控制表，仅当所有该类设备都处于忙碌状态时，才把进程插入到该类设备的等待队列中。只要有一个该类设备空闲，系统便可以计算分配该设备的安全性。若分配不会引起死锁则进行分配，否则仍将该进程插入该类设备的等待队列。

2. 当系统把设备分配给进程后，便可以检查与此设备相连的第一个控制器控制表，从中了解该控制器是否忙碌。若控制器忙，则再检查第二个与设备相连的控制器控制表，若是所有与此设备相连的控制器都忙，则表明没有控制器可以分配给该设备。只要改设备不是该类设备的最后一个，便可以退回到第一步，试图再找下一个空闲设备；否则将该进程插入控制器等待队列中。

3. 若给进程分配了控制器，便可以进一步检查与此控制器相连的第一个通道是否忙碌。若所有通道都忙，表明无通道可以分配给该控制器。只要该控制器不是与设备相连的最后一个控制器，便返回到第二步，试图再找出一个空闲的控制器，否则将该进程插入通道等待队列。若有空闲通道可用，则此次设备分配成功，在将相应的设备、控制器和通道分配给进程后，接着便可以启动I/O设备，开始信息传送。

## 设备管理模拟实验

### 一、相关数据结构

一共定义了五个数据结构，分别是对应进程、通道、控制器、设备和设备表，详细定义如下。

1）进程

```c
1  typedef struct node
2  {
3	char name[10];
4	char devname[10];
5	struct node *next;
6  }PCB;
```

2）通道

```c
1  typedef struct Node
2  {
3	char identify[10];//标识
4	int state;//设备状态
5	PCB *blocking;//阻塞队列指针
6  }CHCT;
```

3）控制器

```c
1  typedef struct NOde
2  {
3	char identify[10];//标识
4	int state;//设备状态
5	CHCT * chct;//CHCT
6	PCB *blocking;//阻塞队列指针
7	struct NOde *next;
8  }COCT;
```

4）设备

```c
1  typedef struct NODe
2  {
3	char identify[10];//标识
4	char type;//设备类型
5	int state;//设备状态
6	int times;//重复执行次数
7	PCB *blocking;//阻塞队列指针
8	COCT * coct;//COCT
9  }DCT;
```

5）设备表

```c
1  typedef struct NODE
2  {
3	char type;//类别
4	char identify[10];//标识
5	DCT * dct;//DCT设备控制表
6	struct NODE *next;
7  }SDT;
```

### 二、设备管理的操作及相关函数介绍

移动到main()函数，可以看到在while循环中可以执行的几种操作分别是增加设备、删除设备、申请设备、回收设备以及设备独立性操作。

1）增加设备

增加设备由函数Adddevice()实现，先查询要增加的设备是否已经存在，若不存在再选择控制器和通道，完成设备的添加。具体实现见代码。

2）删除设备

删除设备由函数Deletedevice()实现，设备不存在或设备正在使用时无法删除，反之则删除设备和相关的控制器。

3）申请设备

申请设备由函数Applydevice()实现，也需要首先判断设备是否存在，然后依次查看设备，与之相关的控制器和通道是否均为空闲，若果是，则进行分配，反之申请失败。

4）回收设备

回收设备由函数Recycledevice()实现，由于无法回收不存在或是出于空闲的设备，因此我们也需要先进行判断，如果满足回收的条件，则进行回收。需要注意的是，在回收设备后需要查看由于各种原因阻塞的进程是否因为该设备的回收可以重新进入就绪状态，如果有，那么将该进程列入就绪状态，反之则不进行任何操作。
